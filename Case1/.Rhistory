fit <- fitdist(x, "norm")
summary(fit)
function_input <- function(theta, y, sigma){
prod(dnorm(y,mean = theta,sd = sigma))
}
function_input(0, x, 1)
log(function_input(0, x, 1))
sum(dnorm(y, mean = theta, sd = sigma, log = TRUE))}
function_log <- function(theta, y, sigma){
sum(dnorm(y, mean = theta, sd = sigma, log = TRUE))
}
function_log(0, y, 1)
function_log(0, x, 1)
?dnorm
function_log <- function(theta, y, sigma){
(dnorm(y, mean = theta, sd = sigma, log = TRUE))
}
dnorm(x, mean = 0, sd = 1, log = TRUE)
fit <- fitdist(rnorm(1000), "norm")
summary(fit)
?weibul
?Exponential
?dnorm
rm(list=ls())
library(ggplot2)
library(patchwork)
library(MASS)
library(survival)
library(dplyr)
library(survminer)
library(lmtest)
df <- cars
df
state.x77
df <- state.x77
df <- data.frame(state.x77)
colnames(df)
head(df)
diamonds
df <- data.frame(diamonds)
colnames(df)
head(df)
df <- data.frame(state.x77)
model <- lm(Income~Illiteracy, data = df)
summary(model)
head(df)
model <- lm(Income ~ Illiteracy + Murder, data = df)
summary(model)
model <- lm(Income ~ Illiteracy + Murder + Life.Exp, data = df)
model
summary(model)
model_1 <- lm(Income ~ Illiteracy, data = df)
model_2 <- lm(Income ~ Illiteracy + Murder, data = df)
model_3 <- lm(Income ~ Illiteracy + Murder + Life.Exp, data = df)
summary(model_1)
summary(model_2)
summary(model_3)
anova(model_1, model_2)
anova(model_2)
summary(model_1)
library(ggplot2)
x <- rnorm(100000, 0, 1)
hist(x)
y <- rnorm(10000, 0, 10)
hist(y)
df <- data.frame(x, y)
ggplot(df) + geom_point(aes(x = x, y = y))
result <- sqrt(2)*(10 - 4*exp(-0.3))/sqrt(1 - exp(-0.6))
result
pnorm(result, 0, 1)
pnorm(10)
pnorm(3)
result <- sqrt(0.2)*(10 - 4*exp(-0.3))/sqrt(1 - exp(-0.6))
result
pnorm(result, 0, 1)
sqrt(0.2)*(10 - 4*exp(-0.3))
sqrt(1 - exp(-0.6))
result
1 - pnorm(result, 0, 1)
library(pracma)
matrixPower = function(M, n)
{
if(n < 1)
{
stop("ARGUMENT n MUST BE POSITIVE INTEGER")
}
result = diag(dim(M)[1])
for(i in 1:n)
{
result = result %*% M
}
return(result)
}
states = 11
mu = 4
p = 1/2
# DEFINING THE MATRIX
P = matrix(rep(0, states*states), nrow = states)
# FILLING THE MATRIX
for(s in 0:9)
{
P[s+1,11] = 1
for(t in 0:9)
{
for(k in 0:min(s,t))
{
P[s+1, t+1] = P[s+1, t+1] + dbinom(k, s, p) * dpois(t-k, mu * p)
}
P[s+1,11] = P[s+1,11] - P[s+1,t+1]
}
}
P[11,11] = 1
# PRINTING THE MATRIX
round(P, 2)
# FINDING THE PROBABILITY OF BEING IN STATE 4 AT n = 10
matrixPower(P,10)[1,5]
#------------------------------------------------------------------------------#
#--- Question 3: --------------------------------------------------------------#
#------------------------------------------------------------------------------#
# DEFINING NEW SYSTEM
Q = P
Q[11,1] = 1
Q[11,11] = 0
# INITIATING FIRST-STEP ANALYSIS
V = Q[2:11, 2:11]
for(i in 1:10)
{
V[i,i] = V[i,i] - 1
}
b = rep(-1, 10)
# FINDING v_0, v_1, ... , v_10
hittingTimes = solve(V,b)
# FINFING T
dot(Q[1,2:11], hittingTimes)
#--------------------------------------------------------------------------#
# INCLUDE LIBRARIES.                                                       #
#--------------------------------------------------------------------------#
library(pracma)
library(pracma)
#--------------------------------------------------------------------------#
# INCLUDE LIBRARIES.                                                       #
#--------------------------------------------------------------------------#
library(pracma)
install.packages("pracma")
install.packages("pracma")
#--------------------------------------------------------------------------#
# INCLUDE LIBRARIES.                                                       #
#--------------------------------------------------------------------------#
library(pracma)
?dot
install.packages("pracma")
#--------------------------------------------------------------------------#
# INCLUDE LIBRARIES.                                                       #
#--------------------------------------------------------------------------#
library(pracma)
matrixPower = function(M, n)
{
if(n < 1)
{
stop("ARGUMENT n MUST BE POSITIVE INTEGER")
}
result = diag(dim(M)[1])
for(i in 1:n)
{
result = result %*% M
}
return(result)
}
#------------------------------------------------------------------------------#
#--- Question 1: --------------------------------------------------------------#
#------------------------------------------------------------------------------#
# NO CODE FOR THIS QUESTION
#------------------------------------------------------------------------------#
#--- Question 2: --------------------------------------------------------------#
#------------------------------------------------------------------------------#
# PARAMETERS
states = 11
mu = 4
p = 1/2
# DEFINING THE MATRIX
P = matrix(rep(0, states*states), nrow = states)
# FILLING THE MATRIX
for(s in 0:9)
{
P[s+1,11] = 1
for(t in 0:9)
{
for(k in 0:min(s,t))
{
P[s+1, t+1] = P[s+1, t+1] + dbinom(k, s, p) * dpois(t-k, mu * p)
}
P[s+1,11] = P[s+1,11] - P[s+1,t+1]
}
}
P[11,11] = 1
# PRINTING THE MATRIX
round(P, 2)
# FINDING THE PROBABILITY OF BEING IN STATE 4 AT n = 10
matrixPower(P,10)[1,5]
#------------------------------------------------------------------------------#
#--- Question 3: --------------------------------------------------------------#
#------------------------------------------------------------------------------#
# DEFINING NEW SYSTEM
Q = P
Q[11,1] = 1
Q[11,11] = 0
# INITIATING FIRST-STEP ANALYSIS
V = Q[2:11, 2:11]
for(i in 1:10)
{
V[i,i] = V[i,i] - 1
}
b = rep(-1, 10)
# FINDING v_0, v_1, ... , v_10
hittingTimes = solve(V,b)
# FINFING T
dot(Q[1,2:11], hittingTimes)
#------------------------------------------------------------------------------#
#--- Question 4: --------------------------------------------------------------#
#------------------------------------------------------------------------------#
prob = 1
for(i in 1:8)
{
prob = prob*(1-matrixPower(Q,i))[1,11]
}
# RESULT
prob
# ALTERNATIVE
sum(matrixPower(Q[1:10,1:10], 8)[1,])
#------------------------------------------------------------------------------#
#--- Question 5: --------------------------------------------------------------#
#------------------------------------------------------------------------------#
# BUILD MATRIX FOR FIRST-STEP ANALYSIS
U = Q[2:10, 2:10]
for(i in 1:9)
{
U[i,i] = U[i,i] - 1
}
# FIND P(ABS. IN "F")
solve(U, -Q[2:10,11])
# CHECKING THAT 1-P(ABS. IN "F") = P(ABS IN 0)
solve(U, - Q[2:10,1])
#------------------------------------------------------------------------------#
#--- Question 6: --------------------------------------------------------------#
#------------------------------------------------------------------------------#
# BUILD SUBMATRIX AFTER 19 STEPS
Q_19 = matrixPower(Q[2:10,2:10], 19)
# FIND NUMERATOR
a_and_b = dot(solve(U, -Q[2:10,11]), Q_19[4,])
# FIND DENOMINATOR
b = solve(U, -Q[2:10,11])[4]
a_and_b/b
x <- c(71,74,82,76,91,82,82,75,79,82,72,90)
?dnorm
?var
mean(x)
nll <- function(theta, input = x){
-sum(dnorm(input, mean = theta, sd = var(x),
log = TRUE))
}
theta <- mean(x)
nll(theta, input = x)
rm(list=ls())
rm(list=ls())
library(numDeriv)
############ Exercise 1 ############
x <- c(71,74,82,76,91,82,82,75,79,82,72,90)
?optimize
?optimize
theta <- mean(x)
nll(theta, input = x)
x <- c(71,74,82,76,91,82,82,75,79,82,72,90)
nll <- function(theta, input = x){
-sum(dnorm(input, mean = theta, sd = var(x),
log = TRUE))
}
theta <- mean(x)
nll(theta, input = x)
optimizer <- optimize(nll,c(min(x),max(x)),
theta = theta, input=x)
nll <- function(theta, input){
-sum(dnorm(input, mean = theta, sd = var(x),
log = TRUE))
}
theta <- mean(x)
nll(theta, input = x)
optimizer <- optimize(nll,c(min(x),max(x)),
theta = theta, input=x)
nll <- function(theta, input){
-sum(dnorm(input, mean = theta, sd = var(input),
log = TRUE))
}
theta <- mean(x)
nll(theta, input = x)
optimizer <- optimize(nll,c(min(x),max(x)),
theta = theta, input=x)
nll <- function(theta, input){
-sum(dnorm(input, mean = theta, sd = var(input),
log = TRUE))
}
theta <- mean(x)
nll(theta, input = x)
nll <- function(theta, input){
-sum(dnorm(input, mean = theta, sd = var(input),
log = TRUE))
}
# theta <- mean(x)
# nll(theta, input = x)
optimizer <- optimize(nll,c(min(x),max(x)), input=x)
optimizer
mean(x)
var(5)
optimizer_mean <- optimize(nll,c(min(x),max(x)), input=mean(x))
optimizer_mean
optimizer_mean <- optimize(nll,c(0, 100), input=mean(x))
optimizer_mean
theta_plotting <- seq(min(x), max(x), 100)
theta_plotting
?seq
theta_plotting <- seq(min(x), max(x), length.out = 100)
theta_plotting
plot(theta_plotting, nll(theta_plotting, x))
test <- nll(theta_plotting, x)
?apply
ll_plotting <- apply(theta_plotting, nll, input = x)
ll_plotting <- sapply(theta_plotting, nll, input = x)
plot(theta_plotting, ll_plotting, type = "l")
ll_plotting <- -sapply(theta_plotting, nll, input = x)
plot(theta_plotting, ll_plotting, type = "l")
plot(theta_plotting, ll_plotting + max(ll_plotting), type = "l")
?optim
ll_plotting <- exp(-sapply(theta_plotting, nll, input = x))
plot(theta_plotting, ll_plotting + max(ll_plotting), type = "l")
plot(theta_plotting, ll_plotting, type = "l")
x <- c(71, 74, 82, 76, 91, 82, 82, 75, 79, 82, 72, 90)
s2 <- var(x)
L.complete.data <- function(theta) {
prod(dnorm(x, mean = theta, sd = sqrt(s2)))
}
x.ave <- mean(x)
n <- length(x)
L.ave <- function(theta) {
dnorm(x.ave, mean = theta, sd = sqrt(s2/n))
}
th <- seq(x.ave - 3 * sqrt(s2), x.ave + 3 * sqrt(s2), length = 200)
L <- sapply(th, L.complete.data)
plot(th, L/max(L), ylab = "L", xlab = expression(theta))
L <- sapply(th, L.ave)
lines(th, L/max(L), col = "red")
plot(th, L/max(L), col = "red", type = "l")
plot(th, L/max(L), ylab = "L", xlab = expression(theta))
plot(th, L/max(L), ylab = "L", xlab = expression(theta), type = "l")
plot(th, L/max(L), ylab = "L", xlab = expression(theta), type = "l")
lines(th, L/max(L), col = "red")
plot(th, L/max(L), ylab = "L", xlab = expression(theta))
L <- sapply(th, L.ave)
lines(th, L/max(L), col = "red")
th <- seq(x.ave - 3 * sqrt(s2), x.ave + 3 * sqrt(s2), length = 200)
L <- sapply(th, L.complete.data)
plot(th, log(L/max(L)), ylab = "L", xlab = expression(theta))
L <- sapply(th, L.ave)
lines(th, log(L/max(L)), col = "red")
th <- seq(x.ave - 3 * sqrt(s2), x.ave + 3 * sqrt(s2), length = 200)
L <- sapply(th, L.complete.data)
plot(th, log(L) - log(max(L)), ylab = "L", xlab = expression(theta))
L <- sapply(th, L.ave)
lines(th, log(L) - log(max(L)), col = "red")
th <- seq(x.ave - 3 * sqrt(s2), x.ave + 3 * sqrt(s2), length = 200)
L <- sapply(th, L.complete.data)
plot(th, log(L/max(L)), ylab = "L", xlab = expression(theta))
L <- sapply(th, L.ave)
lines(th, log(L/max(L)), col = "red")
mean(x)
L.ave <- function(theta) {
-dnorm(x.ave, mean = theta, sd = sqrt(s2/n))
}
th <- seq(x.ave - 3 * sqrt(s2), x.ave + 3 * sqrt(s2), length = 200)
L <- sapply(th, L.complete.data)
plot(th, log(L/max(L)), ylab = "L", xlab = expression(theta))
L <- sapply(th, L.ave)
lines(th, log(L/max(L)), col = "red")
th <- seq(x.ave - 3 * sqrt(s2), x.ave + 3 * sqrt(s2), length = 200)
L <- sapply(th, L.complete.data)
plot(th, log(L) - log(max(L)), ylab = "L", xlab = expression(theta))
L <- sapply(th, L.ave)
lines(th, log(L) - log(max(L)), col = "red")
L.ave <- function(theta) {
dnorm(x.ave, mean = theta, sd = sqrt(s2/n))
}
th <- seq(x.ave - 3 * sqrt(s2), x.ave + 3 * sqrt(s2), length = 200)
L <- sapply(th, L.complete.data)
plot(th, log(L/max(L)), ylab = "L", xlab = expression(theta))
L <- sapply(th, L.ave)
lines(th, log(L/max(L)), col = "red")
th <- seq(x.ave - 3 * sqrt(s2), x.ave + 3 * sqrt(s2), length = 200)
L <- sapply(th, L.complete.data)
plot(th, log(L) - log(max(L)), ylab = "L", xlab = expression(theta))
L <- sapply(th, L.ave)
lines(th, log(L) - log(max(L)), col = "red")
th <- seq(x.ave - 3 * sqrt(s2), x.ave + 3 * sqrt(s2), length = 200)
L <- sapply(th, L.complete.data)
plot(th, -log(L) + log(max(L)), ylab = "L", xlab = expression(theta))
L <- sapply(th, L.ave)
lines(th, -log(L) + log(max(L)), col = "red")
x <- c(71, 74, 82, 76, 91, 82, 82, 75, 79, 82, 72, 90)
s2 <- var(x)
L.complete.data <- function(theta) {
prod(dnorm(x, mean = theta, sd = sqrt(s2)))
}
x.ave <- mean(x)
n <- length(x)
L.ave <- function(theta) {
dnorm(x.ave, mean = theta, sd = sqrt(s2/n))
}
th <- seq(x.ave - 3 * sqrt(s2), x.ave + 3 * sqrt(s2), length = 200)
L <- sapply(th, L.complete.data)
plot(th, log(L/max(L)), ylab = "L", xlab = expression(theta))
L <- sapply(th, L.ave)
lines(th, log(L/max(L)), col = "red")
x.ave
?optim
nll.complete.data <- function(theta) {
-sum(dnorm(x, mean = theta, sd = sqrt(s2), log = TRUE))
}
fit <- optim(x.ave, nll.complete.data, hessian = TRUE,
lower=70, upper=90)
fit[c("convergence", "par", "hessian")]
s2
var(x)
sd(x)
x <- c(4,6,3,7,2,4)
lambda_vector <- seq(0, 10, length.out = 100)
likelihood <- function(lambda){
prod(dpois(x, lambda = lambda))
}
likelihood_plotting <- sapply(lambda_vector, likelihood)
plot(lambda_vector, likelihood_plotting, type = "l")
par(mar=c(1,1,1,1))
plot(lambda_vector, likelihood_plotting, type = "l")
device.off()
x <- c(71, 74, 82, 76, 91, 82, 82, 75, 79, 82, 72, 90)
s2 <- var(x)
L.complete.data <- function(theta) {
prod(dnorm(x, mean = theta, sd = sqrt(s2)))
}
x.ave <- mean(x)
n <- length(x)
L.ave <- function(theta) {
dnorm(x.ave, mean = theta, sd = sqrt(s2/n))
}
th <- seq(x.ave - 3 * sqrt(s2), x.ave + 3 * sqrt(s2), length = 200)
L <- sapply(th, L.complete.data)
plot(th, log(L/max(L)), ylab = "L", xlab = expression(theta))
L <- sapply(th, L.ave)
lines(th, log(L/max(L)), col = "red")
###### UNDERSTANDING INVERSE COVARIANCE ################
library(mvtnorm)
?dmvnorm
x <- 5
x <- 5
library(glmnet)
rm(list=ls())
print(utils::getSrcDirectory(function(){}))
print(utils::getSrcFilename(function(){}, full.names = TRUE))
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# options(scipen=999)
options(scipen=0)
# dev.off()
Sys.setenv(LANG = "en")
library(glmnet)
library(MASS)
library(dplyr)
library(nlme)
#####################3333
df <- data.frame(read.table("preprocessed_data/df_imputed_train.csv", sep="", header=TRUE))
rm(list=ls())
print(utils::getSrcDirectory(function(){}))
print(utils::getSrcFilename(function(){}, full.names = TRUE))
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# options(scipen=999)
options(scipen=0)
# dev.off()
Sys.setenv(LANG = "en")
library(glmnet)
library(MASS)
library(dplyr)
library(nlme)
getwd()
#####################3333
df <- data.frame(read.table("preprocessed_data/df_imputed_train.csv", sep="", header=TRUE))
head(df)
df
#####################3333
df <- read.table("preprocessed_data/df_imputed_train.csv", sep=",", header=TRUE)
dim(df)
head(df)
df[1:10, 1:5]
df[1:10, 1:20]
df <- data.frame(df)
y = df[, "y"]
y
X = df[,-dim(df)[2]]
dim(X)
X[1:10, 1:5]
?glmnet
?glmnet
library(glmnet)
library(MASS)
library(dplyr)
library(nlme)
?glment
?glmnet
